/* automatically generated by rust-bindgen 0.59.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const LZ4_VERSION_MAJOR: u32 = 1;
pub const LZ4_VERSION_MINOR: u32 = 9;
pub const LZ4_VERSION_RELEASE: u32 = 3;
pub const LZ4_VERSION_NUMBER: u32 = 10903;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const LZ4_STREAMSIZE: u32 = 16416;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
extern "C" {
    pub fn LZ4_versionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_versionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " LZ4_compress_default() :"]
    #[doc = "  Compresses 'srcSize' bytes from buffer 'src'"]
    #[doc = "  into already allocated 'dst' buffer of size 'dstCapacity'."]
    #[doc = "  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize)."]
    #[doc = "  It also runs faster, so it's a recommended setting."]
    #[doc = "  If the function cannot compress 'src' into a more limited 'dst' budget,"]
    #[doc = "  compression stops *immediately*, and the function result is zero."]
    #[doc = "  In which case, 'dst' content is undefined (invalid)."]
    #[doc = "      srcSize : max supported value is LZ4_MAX_INPUT_SIZE."]
    #[doc = "      dstCapacity : size of buffer 'dst' (which must be already allocated)"]
    #[doc = "     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)"]
    #[doc = "                or 0 if compression fails"]
    #[doc = " Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer)."]
    pub fn LZ4_compress_default(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() :"]
    #[doc = "  compressedSize : is the exact complete size of the compressed block."]
    #[doc = "  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size."]
    #[doc = " @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)"]
    #[doc = "           If destination buffer is not large enough, decoding will stop and output an error code (negative value)."]
    #[doc = "           If the source stream is detected malformed, the function will stop decoding and return a negative result."]
    #[doc = " Note 1 : This function is protected against malicious data packets :"]
    #[doc = "          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,"]
    #[doc = "          even if the compressed block is maliciously modified to order the decoder to do these actions."]
    #[doc = "          In such case, the decoder stops immediately, and considers the compressed block malformed."]
    #[doc = " Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them."]
    #[doc = "          The implementation is free to send / store / derive this information in whichever way is most beneficial."]
    #[doc = "          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead."]
    pub fn LZ4_decompress_safe(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compressBound() :"]
    #[doc = "Provides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible)"]
    #[doc = "This function is primarily useful for memory allocation purposes (destination buffer size)."]
    #[doc = "Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example)."]
    #[doc = "Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)"]
    #[doc = "inputSize  : max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = "return : maximum output size in a \"worst case\" scenario"]
    #[doc = "or 0, if input size is incorrect (too large or negative)"]
    pub fn LZ4_compressBound(inputSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() :"]
    #[doc = "Same as LZ4_compress_default(), but allows selection of \"acceleration\" factor."]
    #[doc = "The larger the acceleration value, the faster the algorithm, but also the lesser the compression."]
    #[doc = "It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed."]
    #[doc = "An acceleration value of \"1\" is the same as regular LZ4_compress_default()"]
    #[doc = "Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c)."]
    #[doc = "Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c)."]
    pub fn LZ4_compress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState() :"]
    #[doc = "  Same as LZ4_compress_fast(), using an externally allocated memory space for its state."]
    #[doc = "  Use LZ4_sizeofState() to know how much memory must be allocated,"]
    #[doc = "  and allocate it on 8-bytes boundaries (using `malloc()` typically)."]
    #[doc = "  Then, provide this buffer as `void* state` to compression function."]
    pub fn LZ4_sizeofState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_fast_extState(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() :"]
    #[doc = "  Reverse the logic : compresses as much data as possible from 'src' buffer"]
    #[doc = "  into already allocated buffer 'dst', of size >= 'targetDestSize'."]
    #[doc = "  This function either compresses the entire 'src' content into 'dst' if it's large enough,"]
    #[doc = "  or fill 'dst' buffer completely with as much data as possible from 'src'."]
    #[doc = "  note: acceleration parameter is fixed to \"default\"."]
    #[doc = ""]
    #[doc = " *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'."]
    #[doc = "               New value is necessarily <= input value."]
    #[doc = " @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)"]
    #[doc = "           or 0 if compression fails."]
    #[doc = ""]
    #[doc = " Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):"]
    #[doc = "        the produced compressed content could, in specific circumstances,"]
    #[doc = "        require to be decompressed into a destination buffer larger"]
    #[doc = "        by at least 1 byte than the content to decompress."]
    #[doc = "        If an application uses `LZ4_compress_destSize()`,"]
    #[doc = "        it's highly recommended to update liblz4 to v1.9.2 or better."]
    #[doc = "        If this can't be done or ensured,"]
    #[doc = "        the receiving decompression function should provide"]
    #[doc = "        a dstCapacity which is > decompressedSize, by at least 1 byte."]
    #[doc = "        See https://github.com/lz4/lz4/issues/859 for details"]
    pub fn LZ4_compress_destSize(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() :"]
    #[doc = "  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',"]
    #[doc = "  into destination buffer 'dst' of size 'dstCapacity'."]
    #[doc = "  Up to 'targetOutputSize' bytes will be decoded."]
    #[doc = "  The function stops decoding on reaching this objective."]
    #[doc = "  This can be useful to boost performance"]
    #[doc = "  whenever only the beginning of a block is required."]
    #[doc = ""]
    #[doc = " @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)"]
    #[doc = "           If source stream is detected malformed, function returns a negative result."]
    #[doc = ""]
    #[doc = "  Note 1 : @return can be < targetOutputSize, if compressed block contains less data."]
    #[doc = ""]
    #[doc = "  Note 2 : targetOutputSize must be <= dstCapacity"]
    #[doc = ""]
    #[doc = "  Note 3 : this function effectively stops decoding on reaching targetOutputSize,"]
    #[doc = "           so dstCapacity is kind of redundant."]
    #[doc = "           This is because in older versions of this function,"]
    #[doc = "           decoding operation would still write complete sequences."]
    #[doc = "           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,"]
    #[doc = "           it could write more bytes, though only up to dstCapacity."]
    #[doc = "           Some \"margin\" used to be required for this operation to work properly."]
    #[doc = "           Thankfully, this is no longer necessary."]
    #[doc = "           The function nonetheless keeps the same signature, in an effort to preserve API compatibility."]
    #[doc = ""]
    #[doc = "  Note 4 : If srcSize is the exact size of the block,"]
    #[doc = "           then targetOutputSize can be any value,"]
    #[doc = "           including larger than the block's decompressed size."]
    #[doc = "           The function will, at most, generate block's decompressed size."]
    #[doc = ""]
    #[doc = "  Note 5 : If srcSize is _larger_ than block's compressed size,"]
    #[doc = "           then targetOutputSize **MUST** be <= block's decompressed size."]
    #[doc = "           Otherwise, *silent corruption will occur*."]
    pub fn LZ4_decompress_safe_partial(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_stream_t = LZ4_stream_u;
extern "C" {
    pub fn LZ4_createStream() -> *mut LZ4_stream_t;
}
extern "C" {
    pub fn LZ4_freeStream(streamPtr: *mut LZ4_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream_fast() : v1.9.0+"]
    #[doc = "  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks"]
    #[doc = "  (e.g., LZ4_compress_fast_continue())."]
    #[doc = ""]
    #[doc = "  An LZ4_stream_t must be initialized once before usage."]
    #[doc = "  This is automatically done when created by LZ4_createStream()."]
    #[doc = "  However, should the LZ4_stream_t be simply declared on stack (for example),"]
    #[doc = "  it's necessary to initialize it first, using LZ4_initStream()."]
    #[doc = ""]
    #[doc = "  After init, start any new stream with LZ4_resetStream_fast()."]
    #[doc = "  A same LZ4_stream_t can be re-used multiple times consecutively"]
    #[doc = "  and compress multiple streams,"]
    #[doc = "  provided that it starts each new stream with LZ4_resetStream_fast()."]
    #[doc = ""]
    #[doc = "  LZ4_resetStream_fast() is much faster than LZ4_initStream(),"]
    #[doc = "  but is not compatible with memory regions containing garbage data."]
    #[doc = ""]
    #[doc = "  Note: it's only useful to call LZ4_resetStream_fast()"]
    #[doc = "        in the context of streaming compression."]
    #[doc = "        The *extState* functions perform their own resets."]
    #[doc = "        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive."]
    pub fn LZ4_resetStream_fast(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() :"]
    #[doc = "  Use this function to reference a static dictionary into LZ4_stream_t."]
    #[doc = "  The dictionary must remain available during compression."]
    #[doc = "  LZ4_loadDict() triggers a reset, so any previous data will be forgotten."]
    #[doc = "  The same dictionary will have to be loaded on decompression side for successful decoding."]
    #[doc = "  Dictionary are useful for better compression of small data (KB range)."]
    #[doc = "  While LZ4 accept any input as dictionary,"]
    #[doc = "  results are generally better when using Zstandard's Dictionary Builder."]
    #[doc = "  Loading a size of 0 is allowed, and is the same as reset."]
    #[doc = " @return : loaded dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() :"]
    #[doc = "  Compress 'src' content using data from previously compressed blocks, for better compression ratio."]
    #[doc = " 'dst' buffer must be already allocated."]
    #[doc = "  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster."]
    #[doc = ""]
    #[doc = " @return : size of compressed block"]
    #[doc = "           or 0 if there is an error (typically, cannot fit into 'dst')."]
    #[doc = ""]
    #[doc = "  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block."]
    #[doc = "           Each block has precise boundaries."]
    #[doc = "           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata."]
    #[doc = "           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together."]
    #[doc = ""]
    #[doc = "  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !"]
    #[doc = ""]
    #[doc = "  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB."]
    #[doc = "           Make sure that buffers are separated, by at least one byte."]
    #[doc = "           This construction ensures that each block only depends on previous block."]
    #[doc = ""]
    #[doc = "  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB."]
    #[doc = ""]
    #[doc = "  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed."]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() :"]
    #[doc = "  If last 64KB data cannot be guaranteed to remain available at its current memory location,"]
    #[doc = "  save it into a safer place (char* safeBuffer)."]
    #[doc = "  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),"]
    #[doc = "  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables."]
    #[doc = " @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamDecode_t = LZ4_streamDecode_u;
extern "C" {
    #[doc = " LZ4_createStreamDecode() and LZ4_freeStreamDecode() :"]
    #[doc = "  creation / destruction of streaming decompression tracking context."]
    #[doc = "  A tracking context can be re-used multiple times."]
    pub fn LZ4_createStreamDecode() -> *mut LZ4_streamDecode_t;
}
extern "C" {
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4_streamDecode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() :"]
    #[doc = "  An LZ4_streamDecode_t context can be allocated once and re-used multiple times."]
    #[doc = "  Use this function to start decompression of a new stream of blocks."]
    #[doc = "  A dictionary can optionally be set. Use NULL or size 0 for a reset order."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression."]
    #[doc = " @return : 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decoderRingBufferSize() : v1.8.2+"]
    #[doc = "  Note : in a ring buffer scenario (optional),"]
    #[doc = "  blocks are presumed decompressed next to each other"]
    #[doc = "  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),"]
    #[doc = "  at which stage it resumes from beginning of ring buffer."]
    #[doc = "  When setting such a ring buffer for streaming decompression,"]
    #[doc = "  provides the minimum size of this ring buffer"]
    #[doc = "  to be compatible with any source respecting maxBlockSize condition."]
    #[doc = " @return : minimum ring buffer size,"]
    #[doc = "           or 0 if there is an error (invalid maxBlockSize)."]
    pub fn LZ4_decoderRingBufferSize(maxBlockSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_continue() :"]
    #[doc = "  These decoding functions allow decompression of consecutive blocks in \"streaming\" mode."]
    #[doc = "  A block is an unsplittable entity, it must be presented entirely to a decompression function."]
    #[doc = "  Decompression functions only accepts one block at a time."]
    #[doc = "  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded."]
    #[doc = "  If less than 64KB of data has been decoded, all the data must be present."]
    #[doc = ""]
    #[doc = "  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :"]
    #[doc = "  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize)."]
    #[doc = "    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized."]
    #[doc = "    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize."]
    #[doc = "  - Synchronized mode :"]
    #[doc = "    Decompression buffer size is _exactly_ the same as compression buffer size,"]
    #[doc = "    and follows exactly same update rule (block boundaries at same positions),"]
    #[doc = "    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),"]
    #[doc = "    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = "  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized,"]
    #[doc = "    and encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = ""]
    #[doc = "  Whenever these conditions are not possible,"]
    #[doc = "  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,"]
    #[doc = "  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block."]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_usingDict() :"]
    #[doc = "  These decoding functions work the same as"]
    #[doc = "  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()"]
    #[doc = "  They are stand-alone, and don't need an LZ4_streamDecode_t structure."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during decompression."]
    #[doc = "  Performance tip : Decompression speed can be substantially increased"]
    #[doc = "                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapcity: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type LZ4_i8 = i8;
pub type LZ4_byte = u8;
pub type LZ4_u16 = u16;
pub type LZ4_u32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [LZ4_u32; 4096usize],
    pub currentOffset: LZ4_u32,
    pub tableType: LZ4_u32,
    pub dictionary: *const LZ4_byte,
    pub dictCtx: *const LZ4_stream_t_internal,
    pub dictSize: LZ4_u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).hashTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).currentOffset as *const _ as usize
        },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).tableType as *const _ as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictionary as *const _ as usize
        },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictCtx as *const _ as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictCtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictSize as *const _ as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const LZ4_byte,
    pub extDictSize: size_t,
    pub prefixEnd: *const LZ4_byte,
    pub prefixSize: size_t,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).externalDict as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).extDictSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixEnd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_u {
    pub table: [*mut ::std::os::raw::c_void; 2052usize],
    pub internal_donotuse: LZ4_stream_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_stream_u() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_u>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_u>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_u>())).internal_donotuse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_initStream() : v1.9.0+"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is automatically done when invoking LZ4_createStream(),"]
    #[doc = "  but it's not when the structure is simply declared on stack (for example)."]
    #[doc = ""]
    #[doc = "  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t."]
    #[doc = "  It can also initialize any arbitrary buffer of sufficient size,"]
    #[doc = "  and will @return a pointer of proper type upon initialization."]
    #[doc = ""]
    #[doc = "  Note : initialization fails if size and alignment conditions are not respected."]
    #[doc = "         In which case, the function will @return NULL."]
    #[doc = "  Note2: An LZ4_stream_t structure guarantees correct alignment and size."]
    #[doc = "  Note3: Before v1.9.0, use LZ4_resetStream() instead"]
    pub fn LZ4_initStream(buffer: *mut ::std::os::raw::c_void, size: size_t) -> *mut LZ4_stream_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_u {
    pub table: [::std::os::raw::c_ulonglong; 4usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_u() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_u>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_streamDecode_u>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_u>())).internal_donotuse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " Obsolete compression functions (since v1.7.3)"]
    pub fn LZ4_compress(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete decompression functions (since v1.8.0)"]
    pub fn LZ4_uncompress(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        outputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_uncompress_unknownOutputSize(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        isize_: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_create(inputBuffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_sizeofStreamState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamState(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBuffer(state: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Obsolete streaming decoding functions (since v1.7.0)"]
    pub fn LZ4_decompress_safe_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete LZ4_decompress_fast variants (since v1.9.0) :"]
    #[doc = "  These functions used to be faster than LZ4_decompress_safe(),"]
    #[doc = "  but this is no longer the case. They are now slower."]
    #[doc = "  This is because LZ4_decompress_fast() doesn't know the input size,"]
    #[doc = "  and therefore must progress more cautiously into the input buffer to not read beyond the end of block."]
    #[doc = "  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability."]
    #[doc = "  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated."]
    #[doc = ""]
    #[doc = "  The last remaining LZ4_decompress_fast() specificity is that"]
    #[doc = "  it can decompress a block without knowing its compressed size."]
    #[doc = "  Such functionality can be achieved in a more secure manner"]
    #[doc = "  by employing LZ4_decompress_safe_partial()."]
    #[doc = ""]
    #[doc = "  Parameters:"]
    #[doc = "  originalSize : is the uncompressed size to regenerate."]
    #[doc = "                 `dst` must be already allocated, its size must be >= 'originalSize' bytes."]
    #[doc = " @return : number of bytes read from source buffer (== compressed size)."]
    #[doc = "           The function expects to finish at block's end exactly."]
    #[doc = "           If the source stream is detected malformed, the function stops decoding and returns a negative result."]
    #[doc = "  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer."]
    #[doc = "         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds."]
    #[doc = "         Also, since match offsets are not validated, match reads from 'src' may underflow too."]
    #[doc = "         These issues never happen if input (compressed) data is correct."]
    #[doc = "         But they may happen if input data is invalid (error or intentional tampering)."]
    #[doc = "         As a consequence, use these functions in trusted environments with trusted data **only**."]
    pub fn LZ4_decompress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() :"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is done with LZ4_initStream(), or LZ4_resetStream()."]
    #[doc = "  Consider switching to LZ4_initStream(),"]
    #[doc = "  invoking LZ4_resetStream() will trigger deprecation warnings in the future."]
    pub fn LZ4_resetStream(streamPtr: *mut LZ4_stream_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
