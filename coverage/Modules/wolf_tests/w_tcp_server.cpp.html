<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>w_tcp_server.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#ifdef WOLF_SYSTEM_SOCKET

#include "w_tcp_server.hpp"
#include &lt;random&gt;

#include "DISABLE_ANALYSIS_BEGIN"
#include &lt;boost/asio/experimental/awaitable_operators.hpp&gt;
#include "DISABLE_ANALYSIS_END"

using w_tcp_server = wolf::system::socket::w_tcp_server;
using w_session_on_data_callback = wolf::system::socket::w_session_on_data_callback;
using w_session_on_timeout_callback = wolf::system::socket::w_session_on_timeout_callback;
using w_session_on_error_callback = wolf::system::socket::w_session_on_error_callback;
using w_socket_options = wolf::system::socket::w_socket_options;
using steady_clock = std::chrono::steady_clock;
using steady_timer = boost::asio::steady_timer;
using io_context = boost::asio::io_context;
using tcp = boost::asio::ip::tcp;
using time_point = std::chrono::steady_clock::time_point;

using namespace boost::asio::experimental::awaitable_operators;

boost::asio::awaitable&lt;std::errc&gt;
<span style = "background-color:#dfd">watchdog(_Inout_ const time_point &amp;p_deadline) noexcept {
  steady_timer _timer(co_await boost::asio::this_coro::executor);
  auto _now = steady_clock::now();</span>

#ifdef __clang__
#pragma unroll
#endif
<span style = "background-color:#dfd">  while (p_deadline &gt; _now) {
    _timer.expires_at(p_deadline);
    co_await _timer.async_wait(boost::asio::use_awaitable);</span>
<span style = "background-color:#fdd">    _now = steady_clock::now();
  }
  co_return std::errc::timed_out;</span>
<span style = "background-color:#dfd">}</span>

boost::asio::awaitable&lt;void&gt;
on_echo(const boost::asio::io_context &amp;p_io_context, tcp::socket &amp;p_socket,
        const std::string &amp;p_conn_id, time_point &amp;p_deadline,
        steady_clock::duration p_timeout,
        const w_session_on_data_callback &amp;p_on_data_callback,
<span style = "background-color:#dfd">        const w_session_on_error_callback &amp;p_on_error_callback) noexcept {
  w_buffer _mut_buffer = {};</span>

#ifdef __clang__
#pragma unroll
#endif
<span style = "background-color:#dfd">  while (!p_io_context.stopped()) {
    p_deadline = steady_clock::now() + p_timeout;</span>

    try {
<span style = "background-color:#dfd">      _mut_buffer.used_bytes = co_await p_socket.async_receive(</span>
          boost::asio::buffer(_mut_buffer.buf), boost::asio::use_awaitable);

      // call callback
<span style = "background-color:#dfd">      const auto _res = p_on_data_callback(p_conn_id, _mut_buffer);
      co_await p_socket.async_send(</span>
          boost::asio::buffer(_mut_buffer.buf, _mut_buffer.used_bytes),
          boost::asio::use_awaitable);

<span style = "background-color:#dfd">      if (_res == boost::system::errc::connection_aborted) {
        break;</span>
      }
<span style = "background-color:#fdd">    } catch (const std::exception &amp;p_ex) {
      p_on_error_callback(p_conn_id, p_ex);
      break;
    }</span>
<span style = "background-color:#dfd">  }
}</span>

boost::asio::awaitable&lt;void&gt; handle_connection(
    const boost::asio::io_context &amp;p_io_context, tcp::socket p_socket,
    steady_clock::duration p_timeout,
    w_session_on_data_callback p_on_data_callback,
    w_session_on_timeout_callback p_on_timeout_callback,
<span style = "background-color:#dfd">    w_session_on_error_callback p_on_error_callback) noexcept {</span>

<span style = "background-color:#dfd">  constexpr auto _max = 999;
  constexpr auto _min = 9;
  std::default_random_engine _rand_engine {};
  std::uniform_int_distribution&lt;int&gt; _rand_gen(_min, _max);</span>

<span style = "background-color:#dfd">  auto _rand_num = _rand_gen(_rand_engine);</span>

#ifdef __clang__
// Get UTC time
  time_t _current_time = time(NULL);
  tm* tm_gmt = gmtime(&amp;_current_time);
  
  auto size = std::snprintf(nullptr, 0, "%d-%02d-%02d %02d:%02d:%d_%d",
  	tm_gmt-&gt;tm_year + 1900, tm_gmt-&gt;tm_mon, tm_gmt-&gt;tm_mday,
  	tm_gmt-&gt;tm_hour, tm_gmt-&gt;tm_min, tm_gmt-&gt;tm_sec, 36);
  
  std::string _conn_id(size + 1, '\0');
  
  std::sprintf(&amp;_conn_id[0], "%d-%02d-%02d %02d:%02d:%d_%d",
  	tm_gmt-&gt;tm_year + 1900, tm_gmt-&gt;tm_mon, tm_gmt-&gt;tm_mday,
  	tm_gmt-&gt;tm_hour, tm_gmt-&gt;tm_min, tm_gmt-&gt;tm_sec, 36);
#else  
<span style = "background-color:#dfd">  const auto _conn_id =</span>
      std::format("{}_{}", std::chrono::utc_clock::now(), _rand_num);
#endif

<span style = "background-color:#dfd">  time_point _deadline = {};
  auto _ret =</span>
      co_await (on_echo(p_io_context, p_socket, _conn_id, _deadline, p_timeout,
                        p_on_data_callback, p_on_error_callback) ||
                watchdog(_deadline));
<span style = "background-color:#dfd">  if (std::get&lt;1&gt;(_ret) == std::errc::timed_out) {</span>
<span style = "background-color:#fdd">    p_on_timeout_callback(_conn_id);</span>
  }
<span style = "background-color:#dfd">}</span>

boost::asio::awaitable&lt;void&gt;
listen(boost::asio::io_context &amp;p_io_context, tcp::endpoint &amp;p_endpoint,
       steady_clock::duration &amp;p_timeout, w_socket_options &amp;p_socket_options,
       w_session_on_data_callback p_on_data_callback,
       w_session_on_timeout_callback p_on_timeout_callback,
<span style = "background-color:#dfd">       w_session_on_error_callback p_on_error_callback) noexcept {
  auto _executor = co_await boost::asio::this_coro::executor;
  tcp::acceptor _acceptor(_executor, p_endpoint);</span>

  // set acceptor's options
  const auto _keep_alive_option =
<span style = "background-color:#dfd">      boost::asio::socket_base::keep_alive(p_socket_options.keep_alive);
  _acceptor.set_option(_keep_alive_option);</span>

  const auto _reuse_address_option =
<span style = "background-color:#dfd">      boost::asio::socket_base::reuse_address(p_socket_options.reuse_address);
  _acceptor.set_option(_reuse_address_option);</span>

#ifdef __clang__
#pragma unroll
#endif
<span style = "background-color:#dfd">  while (!p_io_context.stopped()) {
    tcp::socket _socket =</span>
        co_await _acceptor.async_accept(boost::asio::use_awaitable);

    // set socket's options
    const auto _no_delay_opt =
<span style = "background-color:#dfd">        boost::asio::ip::tcp::no_delay(p_socket_options.no_delay);
    _socket.set_option(_no_delay_opt);
    _socket.set_option(_keep_alive_option);
    _socket.set_option(_reuse_address_option);</span>

    // spawn a coroutinue for handling connection
<span style = "background-color:#dfd">    co_spawn(_executor,</span>
             handle_connection(p_io_context, std::move(_socket), p_timeout,
                               p_on_data_callback, p_on_timeout_callback,
                               p_on_error_callback),
             boost::asio::detached);
<span style = "background-color:#dfd">  }</span>
<span style = "background-color:#fdd">}</span>

void w_tcp_server::run(
    boost::asio::io_context &amp;p_io_context, tcp::endpoint &amp;&amp;p_endpoint,
    std::chrono::steady_clock::duration &amp;&amp;p_timeout,
    w_socket_options &amp;&amp;p_socket_options,
    w_session_on_data_callback p_on_data_callback,
    w_session_on_timeout_callback p_on_timeout_callback,
<span style = "background-color:#dfd">    w_session_on_error_callback p_on_error_callback) noexcept {
  boost::asio::co_spawn(p_io_context,</span>
                        listen(p_io_context, p_endpoint, p_timeout,
                               p_socket_options, p_on_data_callback,
                               p_on_timeout_callback, p_on_error_callback),
                        boost::asio::detached);
<span style = "background-color:#dfd">}</span>

#endif</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>