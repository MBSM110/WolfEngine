<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>w_ffmpeg.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
ï»¿#ifdef WOLF_MEDIA_FFMPEG

#include "w_ffmpeg.hpp"

#include &lt;DISABLE_ANALYSIS_BEGIN&gt;
extern "C" {
#include &lt;libavutil/opt.h&gt;
}
#include &lt;DISABLE_ANALYSIS_END&gt;

using w_ffmpeg = wolf::media::ffmpeg::w_ffmpeg;
using w_ffmpeg_ctx = wolf::media::ffmpeg::w_ffmpeg_ctx;
using w_av_config = wolf::media::ffmpeg::w_av_config;
using w_av_codec_opt = wolf::media::ffmpeg::w_av_codec_opt;
using w_av_set_opt = wolf::media::ffmpeg::w_av_set_opt;
using w_encoder = wolf::media::ffmpeg::w_encoder;
using w_decoder = wolf::media::ffmpeg::w_decoder;

static boost::leaf::result&lt;int&gt;
create(_Inout_ w_ffmpeg_ctx &amp;p_ctx, _In_ const w_av_config &amp;p_config,
       _In_ const std::string_view p_id,
       _In_ const w_av_codec_opt &amp;p_codec_opts,
<span style = "background-color:#fdd">       _In_ const std::vector&lt;w_av_set_opt&gt; &amp;p_opts) noexcept {</span>

<span style = "background-color:#fdd">  p_ctx.codec_ctx = avcodec_alloc_context3(p_ctx.codec);
  auto _context_nn = gsl::narrow_cast&lt;AVCodecContext *&gt;(p_ctx.codec_ctx);</span>

<span style = "background-color:#fdd">  _context_nn-&gt;width = p_config.width;
  _context_nn-&gt;height = p_config.height;
  _context_nn-&gt;bit_rate = p_codec_opts.bitrate;
  _context_nn-&gt;time_base = AVRational{1, p_codec_opts.fps};
  _context_nn-&gt;framerate = AVRational{p_codec_opts.fps, 1};
  _context_nn-&gt;pix_fmt = p_config.format;</span>

  // set gop
<span style = "background-color:#fdd">  if (p_codec_opts.gop &gt;= 0) {
    _context_nn-&gt;gop_size = gsl::narrow_cast&lt;int&gt;(p_codec_opts.gop);</span>
  }
  // set refs
<span style = "background-color:#fdd">  if (p_codec_opts.refs &gt;= 0) {
    _context_nn-&gt;refs = gsl::narrow_cast&lt;int&gt;(p_codec_opts.refs);</span>
  }
  // set frames
<span style = "background-color:#fdd">  if (p_codec_opts.max_b_frames &gt;= 0) {
    _context_nn-&gt;max_b_frames =</span>
        gsl::narrow_cast&lt;int&gt;(p_codec_opts.max_b_frames);
  }
  // set thread numbers
<span style = "background-color:#fdd">  if (p_codec_opts.thread_count &gt;= 0) {
    _context_nn-&gt;thread_count =</span>
        gsl::narrow_cast&lt;int&gt;(p_codec_opts.thread_count);
  }
  // set level
<span style = "background-color:#fdd">  if (p_codec_opts.level &gt;= 0) {
    _context_nn-&gt;level = p_codec_opts.level;</span>
  }
  // set flags
<span style = "background-color:#fdd">  if (_context_nn-&gt;flags &amp; AVFMT_GLOBALHEADER) {
    _context_nn-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span>
  }

<span style = "background-color:#fdd">  for (const auto &amp;_opt : p_opts) {
    if (_opt.name.empty() == true) {
      continue;</span>
    }

<span style = "background-color:#fdd">    auto _name_str = _opt.name.c_str();
    if (std::holds_alternative&lt;int&gt;(_opt.value)) {</span>
      // set an integer value
<span style = "background-color:#fdd">      const auto _value = std::get&lt;int&gt;(_opt.value);
      const auto _ret =</span>
          av_opt_set_int(_context_nn-&gt;priv_data, _name_str, _value, 0);
<span style = "background-color:#fdd">      if (_ret &lt; 0) {
        std::string _value_str;</span>
        try {
<span style = "background-color:#fdd">          _value_str = std::to_string(_value);
        } catch (...) {
        };
        return W_ERR(std::errc::invalid_argument,</span>
                     "could not set int value for " + _opt.name + ":" +
                         _value_str + " because " +
                         w_ffmpeg_ctx::get_av_error_str(_ret));
<span style = "background-color:#fdd">      }
    } else if (std::holds_alternative&lt;double&gt;(_opt.value)) {</span>
      // set double value
<span style = "background-color:#fdd">      const auto _value = std::get&lt;int&gt;(_opt.value);
      const auto _ret =</span>
          av_opt_set_double(_context_nn-&gt;priv_data, _name_str, _value, 0);
<span style = "background-color:#fdd">      if (_ret &lt; 0) {
        std::string _value_str;</span>
        try {
<span style = "background-color:#fdd">          _value_str = std::to_string(_value);
        } catch (...) {
        };
        return W_ERR(std::errc::invalid_argument,</span>
                     "could not set double value for " + _opt.name + ":" +
                         _value_str + " because " +
                         w_ffmpeg_ctx::get_av_error_str(_ret));
      }
<span style = "background-color:#fdd">    } else {</span>
      // set string value
<span style = "background-color:#fdd">      const auto _value_str = std::get&lt;std::string&gt;(_opt.value);
      if (_value_str.empty() == false) {
        const auto _ret = av_opt_set(_context_nn-&gt;priv_data, _opt.name.c_str(),</span>
                                     _value_str.c_str(), 0);
<span style = "background-color:#fdd">        if (_ret &lt; 0) {
          return W_ERR(std::errc::invalid_argument,</span>
                       "could not set string value for " + _opt.name + ":" +
                           _value_str + " because " +
                           w_ffmpeg_ctx::get_av_error_str(_ret));
        }
      }
<span style = "background-color:#fdd">    }
  }</span>

  // open avcodec
<span style = "background-color:#fdd">  const auto _ret = avcodec_open2(_context_nn, _context_nn-&gt;codec, nullptr);
  if (_ret &lt; 0) {
    return W_ERR(std::errc::operation_canceled,</span>
                 "could not open avcodec because " +
                     w_ffmpeg_ctx::get_av_error_str(_ret));
  }
<span style = "background-color:#fdd">  return W_OK();
}</span>

boost::leaf::result&lt;w_encoder&gt; w_ffmpeg::create_encoder(
    _In_ const w_av_config &amp;p_config, _In_ const std::string &amp;p_id,
    _In_ const w_av_codec_opt &amp;p_codec_opts,
<span style = "background-color:#fdd">    _In_ const std::vector&lt;w_av_set_opt&gt; &amp;p_opts) noexcept {</span>

<span style = "background-color:#fdd">  w_encoder _encoder = {};</span>

<span style = "background-color:#fdd">  _encoder.ctx.codec = avcodec_find_encoder_by_name(p_id.c_str());
  if (_encoder.ctx.codec == nullptr) {
    return W_ERR(std::errc::invalid_argument,</span>
                 "could not find encoder codec id: " + p_id);
  }

<span style = "background-color:#fdd">  BOOST_LEAF_CHECK(create(_encoder.ctx, p_config, p_id, p_codec_opts, p_opts));</span>

<span style = "background-color:#fdd">  return _encoder;
}</span>

boost::leaf::result&lt;w_decoder&gt; w_ffmpeg::create_decoder(
    _In_ const w_av_config &amp;p_config, _In_ const std::string &amp;p_id,
    _In_ const w_av_codec_opt &amp;p_settings,
<span style = "background-color:#fdd">    _In_ const std::vector&lt;w_av_set_opt&gt; &amp;p_opts) noexcept {</span>

<span style = "background-color:#fdd">  w_decoder _decoder = {};</span>

<span style = "background-color:#fdd">  _decoder.ctx.codec = avcodec_find_decoder_by_name(p_id.c_str());
  if (_decoder.ctx.codec == nullptr) {
    return W_ERR(std::errc::invalid_argument,</span>
                 "could not find decoder codec id: " + p_id);
  }
<span style = "background-color:#fdd">  _decoder.ctx.parser = av_parser_init(_decoder.ctx.codec-&gt;id);
  if (_decoder.ctx.parser == nullptr) {
    return W_ERR(std::errc::invalid_argument,</span>
                 "could not initialize parser for codec id: " + p_id);
  }

<span style = "background-color:#fdd">  BOOST_LEAF_CHECK(create(_decoder.ctx, p_config, p_id, p_settings, p_opts));</span>

<span style = "background-color:#fdd">  return _decoder;
}</span>

#endif // WOLF_MEDIA_FFMPEG</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>